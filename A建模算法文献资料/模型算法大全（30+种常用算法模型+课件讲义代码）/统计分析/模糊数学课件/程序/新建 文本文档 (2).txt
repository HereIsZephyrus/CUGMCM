1.原理

模糊综合评判方法即将评价目标看成是由多种因素组成的模糊集合（称为因素集u），再设定这些因素所能选取的评审等级，组成评语的模糊集合（称为评判集v），分别求出各单一因素对各个评审等级的归属程度（称为模糊矩阵），然后根据各个因素在评价目标中的权重分配，通过计算（称为模糊矩阵合成），求出评价的定量解值。它是应用模糊变换原理和最大隶属度原则，对各因素作综合评价的。其原理表示为：

B=E×R

式中E={e1,e2,... ,ei,...,em},为模糊向量或称模糊变换器，是评价因素集X={ x1,x2, ,xi, ,xm }的权重分配。

式中R为评价因素X={ x1,x2, ...,xi, ...,xm }与评判集U={ u1,u2, ,ui, ,un }构成的模糊关系矩阵。

    |R1| |r11 r12 ... r1m|

R=|R2|= |r21 r22 ... r2m|


    | |   |                | 

               |Rn |     |rn2     rn2 ... rnm|


其中n为评价集合的个数，m为评价因素(或评判指标)的个数。

2.程序算法

下面是采用环境中的常用的超标加权法计算权重，使用“线性降半阶”函数计算隶属度的matlab程序，供各位参考。

clear;clc;
a=[
48.37611111 26.33277778 819.1455556 334.5933333 1032.364444 262.3716667 2374.722222
15.84 6.430384615 981.3157692 756.1965385 991.7353846 82.82846154 2535.692308
70.7225 29.8525 895.5325 294.5875 1059.1875 462.9525 2724.5
]; %a为评价集标准值
d=[
43.49 28.05 737.98 391.12 1025.66 7.41 2134
2.61 1.82 920.75 636.41 1005.45 74.09 2330
28.66 8.51 774.99 322.78 1013.96 93.84 2001
3.01 1.95 897.53 614.44 889.87 123.27 2200
25.85 5.72 759.59 302.03 1001.96 76.15 1972
2 1.95 1161.68 1003.73 1077.06 110.1 3004
3.81 1.09 820.51 396.61 1004.74 37.04 2019
5.21 2.92 814.08 419.8 1005.8 31.49 2018
4.41 2.8 824.65 449.06 998.36 38.28 2047
3.01 1.58 1220.54 956.14 1244.75 3.91 3071
6.01 2.43 1791.61 2338.17 1278.08 30.87 4362
1.2 2.67 1160.54 821.29 1100.82 85.41 2942
6.61 7.3 865.57 389.31 1065.27 46.51 2244
9.82 3.77 1240.77 939.71 1165.24 177.19 3248
17.64 6.44 884.2 473.49 930.29 218.95 2417
26.65 7.9 839.5 474.71 941.99 184.18 2363
25.25 4.74 808.33 486.31 881.01 191.6 2217
25.45 6.93 852.01 478.37 966.45 182.54 2339
35.27 18.48 785.11 331.32 979.57 4.04 2245
2.81 2.31 1601.02 2533.55 486.73 2.47 3801
4.21 4.86 1815.52 2584.68 963.61 0 4399
15.23 5.35 813.85 787.16 688.79 205.18 2093
67.01 36.65 864.23 357.76 1035.8 426.31 2609
84.65 34.24 892.72 381.19 1060 466.64 2731
15.43 21.52 898.68 88.47 1061.46 414.48 2483
115.8 27 926.5 350.93 1079.49 544.38 3075

]; %b为待判样品值

[m,n]=size(a);
[x,y]=size(d);
TheResultMoHu=[];
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
for s=1:x
    for p=1:n
        b(p)=d(s,p);
    end
    for i=1:n %计算每一个列的平均值
        ColAverage(i)=0;
        for j=1:m
            ColAverage(i)=ColAverage(i)+a(j,i);
        end
        ColAverage(i)=ColAverage(i)/m;
    end
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    ETotal = 0; %超标加权法计算权重
    for j = 1: n
         ETotal = ETotal + (b(j) / ColAverage(j));
    end
    for i = 1: n
        EResult(i) = (b(i) / ColAverage(i)) / ETotal; %EResult为计算结果
    end
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %使用隶属函数，做预处理对每一列进行排序
    SortedMatrix=a;
    for j=1:n
        for i=1:m
            for k=i:m
                if SortedMatrix(i,j)>SortedMatrix(k,j)
                    tmp=SortedMatrix(i,j);
                    SortedMatrix(i,j)=SortedMatrix(k,j);
                    SortedMatrix(k,j)=tmp;
                end
            end
        end
    end

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %计算单因素隶属度

    c=SortedMatrix;
    for j = 1 : n
               for i = 1 : m
                    for k = 1 : m
                        if a(i, j) == c(k, j) 

                            if k == 1 
                                if b(j) < c(k, j) 
                                    LSDResult(j, i) = 1;
                                end
                                if b(j) >= c(k, j) & b(j) < c(k + 1, j) 
                                    LSDResult(j, i) = ((c(k + 1, j) - b(j)) / (c(k + 1, j) - c(k, j)));
                                end
                                if b(j) >= c(k + 1, j) 
                                    LSDResult(j, i) = 0;
                                end
                            end

                            if k > 1 & k < m

                                if b(j) < c(k - 1, j) 
                                    LSDResult(j, i) = 0;
                                end
                                if b(j) >= c(k - 1, j) & b(j) < c(k, j) 
                                    LSDResult(j, i) = ((b(j) - c(k - 1, j)) / (c(k, j) - c(k - 1, j)));
                                end
                                if b(j) >= c(k, j) & b(j) < c(k + 1, j)
                                    LSDResult(j, i) = ((c(k + 1, j) - b(j)) / (c(k + 1, j) - c(k, j)));
                                end
                                if b(j) >= c(k + 1, j) 
                                    LSDResult(j, i) = 0;
                                end
                            end
                            if k == m 

                                if b(j) < c(k - 1, j) 
                                    LSDResult(j, i) = 0;
                                end
                                if b(j) >= c(k - 1, j) & b(j) < c(k, j) 
                                    LSDResult(j, i) = ((b(j) - c(k - 1, j)) / (c(k, j) - c(k - 1, j)));
                                end
                                if b(j) >= c(k, j) 
                                    LSDResult(j, i) = 1;
                                end
                            end
                        end
                    end
               end
    end
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %权重乘以单因素隶属度得到最终结果
     R=LSDResult;
     E=EResult;
    FuzzyEvalution=E*R;
    TheResultMoHu=[TheResultMoHu;FuzzyEvalution];
end
TheResultMoHu
